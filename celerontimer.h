#ifndef CELERON_TIMER_H
#define CELERON_TIMER_H

//-------------------------------------------------------------------
// Библиотека "Программных Таймеров"
//
// Реализация программных задержек: 
//      синхронных (классических, блокирующих - просто цикл)
//      и асинхронных (неблокирующих, обработчики которых реализованы в цикле конечного автомата)
//
//-------------------------------------------------------------------



// Счётчик системных тиков, прошедших со времени включения микроконтроллера (увеличивается каждую 1мс) 
extern volatile uint32_t DELAY_SysTick;

// Важно: Периодичность переполнения разрядной сетки таймера = 2^32 мс = примерно 50 суток. 
// Кроме того, макросы для таймеров, представленные ниже, используют проверки на половину диапазона (0x80000000)...
//              Например, если таймер установлен на время SysTick=X, 
//              то метод DELAY_CheckTimer будет возвращать статус "таймер сработал" в течение SysTick=[X .. X+25суток],
//              а следующие 25 суток SysTick=[X+25суток .. (циклическое переполнение) .. X] таймер будет заблокирован.
//              Но затем, опять наступит время X! И в течение следующих 25 суток SysTick=[X .. X+25суток] таймер опять будет возвращать "сработал"...
// Таким образом, есть два принципиальных ограничения в данной реализации:
//      1) Сработавшие таймеры необходимо явно "выключать" в первые 25 суток после срабатывания 
//              (в обработчике события, либо делать явный вызов DELAY_DisableTimer; 
//              либо переключать какой-то свой флажок; 
//              либо игнорить выключение, но смириться с возможным повторным срабатыванием через 50 суток!)
//      2) Нельзя устанавливать таймер (DELAY_SetTimer) на выдержку более 25 суток!
//  иначе будут глюки (ложные срабатывания или несрабатывания таймера).


//-----------------------------------------------------------------------------


// Создать глобальный таймер (используемый разными модулями) (декларируется вне функций на модульном уровне)
#define DELAY_DeclareGlobalTimer(name)                          \
           volatile uint32_t DELAY_##name##_timer = UINT32_MAX; \
           volatile uint8_t  DELAY_##name##_on    = 0;

// Объявить псевдоним глобального таймера в "заголовочном файле" (используется в паре с DELAY_DeclareGlobalTimer)
#define DELAY_DeclareExternalTimer(name)                        \
    extern volatile uint32_t DELAY_##name##_timer;              \
    extern volatile uint8_t  DELAY_##name##_on;

// Создать локальный таймер (декларируется в пространстве имён конкретной функции, или вне функций на модульном уровне)
#define DELAY_DeclareTimer(name)                                \
    static volatile uint32_t DELAY_##name##_timer = UINT32_MAX; \
    static volatile uint8_t  DELAY_##name##_on    = 0;



// Установить Таймер "name" на "time" мс вперёд от текущего момента
#define DELAY_SetTimer(name, time)                              \
{   DELAY_##name##_timer = DELAY_SysTick + (time);              \
    DELAY_##name##_on    = 1;   }

// Проверить, включен ли Таймер?
#define DELAY_IsTimerOn(name)                                   \
    ( DELAY_##name##_on )

// Выключить Таймер
#define DELAY_DisableTimer(name)                                \
{   DELAY_##name##_on = 0;  }



// Проверить, не вышло ли время Таймера?
// Использовать в цикле автомата:    if(DELAY_CheckTimer(name))  {прикладная реакция; DELAY_DisableTimer(name);}
#define DELAY_CheckTimer(name)                                  \
    ( DELAY_##name##_on &&                                      \
     (DELAY_##name##_timer -1 -DELAY_SysTick) > 0x80000000 )


// Сколько времени (мс) ещё осталось до срабатывания Таймера?
// Использовать в цикле автомата:    if( DELAY_IsTimerOn(name) && DELAY_RemainingTime(name)<10)  {ща рванёт!;}
#define DELAY_RemainingTime(name)                               \
    (DELAY_##name##_timer - DELAY_SysTick)



//-----------------------------------------------------------------------------


void DELAY_Wait_ms(uint32_t time);


#endif // CELERON_TIMER_H
